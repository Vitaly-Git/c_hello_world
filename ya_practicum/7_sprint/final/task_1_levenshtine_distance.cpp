/*
https://contest.yandex.ru/contest/25597/run-report/115019499/

-- ПРИНЦИП РАБОТЫ --
1. Задача оказалась далекой от моей сферы деятельности, поэтому сразу пошел читать.
   https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0 
2. Оказалось, что это типовая задача для редакторов, для определения стоимости редактирования текста.
3. Мы должны понять, как потимально заменить символы в строке, т.е. 
   другими словами, как их оптимально переставить, испробовав все возможные комбинации.
4. И зачастую для таких целей нам может подойти либо жадный алгоритм (далеко не всегда, т.к. он смотрит локальные экстретмумы).
5. Конечно в данном случае просмотр локальных экстремумов нам не даст требуемый результат, как и было в лекциях,
   от него мы можем перейти либо к полному перебору или ирекурсии - а это может быть очень ресурсоемко, либо 
   использовать динамическое программирование - т.е. запоминать результат расчетов и использовать в следуюущем шаге.
6. Выбрал результат с динамическим программированием.
7. Теория данного алгоритма хорошо описана в википедии, и в подобных уроках: https://youtu.be/903VbCD7uBw?si=5ohMN_5IOSAzu5TU
8. Воспользуемся теорией и реализуем алгоритм на языке с++.
8.1. Строим матрицу, где в строках будут буквы одно слова, в столбцах второго
8.2. Последовательно обходим буква за буквой, проверяя, как текущее так и предыущее расчитанные значения.
8.3. Последовательно заполняем всю матрицу, находя минимум.
8.4. В реузльтате в последней ячейке получаем требуемый минимум.
-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
1. Мы используем для расчета ранее посчитанные данные.
2. Мы смотрим все возможные комбинации букв.
3. Ищем минимально возможное решение.
3. Можно добавить доказательство из википедии, но оно объемное: https://ru.wikipedia.org/wiki/%D0%A0%D0%B0%D1%81%D1%81%D1%82%D0%BE%D1%8F%D0%BD%D0%B8%D0%B5_%D0%9B%D0%B5%D0%B2%D0%B5%D0%BD%D1%88%D1%82%D0%B5%D0%B9%D0%BD%D0%B0#%D0%94%D0%BE%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D1%81%D1%82%D0%B2%D0%BE
-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
1. O(КолвоБуквВСлове1 * КолвоБуквВСлове2) - последовательно обходим все буквы слов.
-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
1. O(КолвоБуквВСлове1 * КолвоБуквВСлове2) - для расчета используем матрицу (вектор веторов int).
*/

#include <iostream>
#include <vector>
#include <string>

int main(){

    std::string word1;
    std::string word2;

    // Ввод данных
    std::getline(std::cin, word1);
    std::getline(std::cin, word2);

    // Инициализация матрицы расстояний
    std::vector< std::vector<int> > rowsByWord1(word1.size()+1);
    for (int i=0; i<=word1.size(); ++i){
        rowsByWord1[i] = std::vector<int>(word2.size()+1);
        rowsByWord1[i][0] = i;
    }
    for (int i=0; i<=word2.size(); ++i)
        rowsByWord1[0][i] = i;
        
    // Расчет матрицы расстояний
    for (int y=1; y<=word1.size(); ++y){
        for (int x=1; x<=word2.size(); ++x){
            
            int distLocal = 0;
            
            int leftVal = rowsByWord1[y][x-1] + 1;
            int leftTopVal = rowsByWord1[y-1][x-1] + (word1[y-1] == word2[x-1] ? 0 : 1);
            int toptVal = rowsByWord1[y-1][x] + 1;

            distLocal = std::min(leftVal, leftTopVal);
            distLocal = std::min(distLocal, toptVal);

            rowsByWord1[y][x] = distLocal;
        }
    }

    std::cout << rowsByWord1[word1.size()][word2.size()];

    return 0;
}